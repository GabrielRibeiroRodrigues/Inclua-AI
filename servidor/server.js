// Arquivo: servidor/server.js (GOOGLE GEMINI - VERS√ÉO OTIMIZADA)

// 1. Importa as bibliotecas
const express = require('express');
const { GoogleGenerativeAI } = require('@google/generative-ai');
const dotenv = require('dotenv');
const cors = require('cors');
const path = require('path');

// 2. Carrega as vari√°veis de ambiente do arquivo .env no diret√≥rio atual
dotenv.config({ path: path.join(__dirname, '.env') });

// 3. Valida√ß√£o da chave de API
if (!process.env.GEMINI_API_KEY) {
  console.error('‚ùå ERRO: GEMINI_API_KEY n√£o encontrada no arquivo .env');
  console.log('üí° Crie um arquivo .env com: GEMINI_API_KEY=sua_chave_aqui');
  process.exit(1);
}

// 4. Inicializa o Express e middlewares
const app = express();
// path j√° foi importado acima

app.use(cors());
app.use(express.json({ limit: '10mb' })); // Aumenta limite para imagens

// Middleware para log de requisi√ß√µes
app.use((req, res, next) => {
  const start = Date.now();
  const ip = req.ip || req.connection.remoteAddress || 'unknown';
  
  res.on('finish', () => {
    const duration = Date.now() - start;
    const status = res.statusCode;
    const method = req.method;
    const url = req.url;
    
    const emoji = status >= 400 ? '‚ùå' : status >= 300 ? '‚ö†Ô∏è' : '‚úÖ';
    console.log(`${emoji} ${method} ${url} - ${status} (${duration}ms) [${ip}]`);
  });
  
  next();
});

// Servir arquivos est√°ticos do diret√≥rio pai (onde est√£o index.html, widget.js, etc.)
app.use(express.static(path.join(__dirname, '..')));

// Rota principal para servir o index.html
app.get('/', (req, res) => {
  res.sendFile(path.join(__dirname, '..', 'index.html'));
});

// 5. Inicializa o cliente do Gemini com configura√ß√£o otimizada
const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);
const model = genAI.getGenerativeModel({ 
  model: 'gemini-1.5-flash',
  generationConfig: {
    temperature: 0.7,
    topP: 0.95,
    maxOutputTokens: 1000,
  },
});

// 5.1. Fun√ß√£o para chamar a API do Gemini com retry autom√°tico
async function callGeminiWithRetry(generateFunction, maxRetries = 3) {
  const baseDelay = 1000; // 1 segundo
  
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      console.log(`ü§ñ Tentativa ${attempt}/${maxRetries} - Chamando Gemini API...`);
      const result = await generateFunction();
      console.log(`‚úÖ Sucesso na tentativa ${attempt}`);
      return result;
    } catch (error) {
      const isLastAttempt = attempt === maxRetries;
      const isRetriableError = error.message.includes('overloaded') || 
                              error.message.includes('503') ||
                              error.message.includes('429') ||
                              error.message.includes('quota');
      
      console.warn(`‚ö†Ô∏è Tentativa ${attempt} falhou: ${error.message}`);
      
      if (!isRetriableError || isLastAttempt) {
        throw error;
      }
      
      // Exponential backoff: 1s, 2s, 4s...
      const delay = baseDelay * Math.pow(2, attempt - 1);
      console.log(`‚è≥ Aguardando ${delay}ms antes da pr√≥xima tentativa...`);
      await new Promise(resolve => setTimeout(resolve, delay));
    }
  }
}

// 6. Fun√ß√£o auxiliar melhorada para imagens com valida√ß√£o de seguran√ßa
async function urlToGenerativePart(url) {
  try {
    console.log(`üì• Baixando imagem de: ${url.substring(0, 100)}...`);
    
    // Valida√ß√µes de seguran√ßa
    const urlObj = new URL(url);
    
    // Bloquear protocolos inseguros
    if (!['http:', 'https:', 'data:'].includes(urlObj.protocol)) {
      throw new Error('Protocolo de URL n√£o permitido');
    }
    
    // Bloquear IPs locais (para prevenir SSRF)
    if (urlObj.hostname.match(/^(127\.|10\.|192\.168\.|172\.(1[6-9]|2[0-9]|3[01])\.|localhost$|0\.0\.0\.0$)/)) {
      throw new Error('Acesso a recursos locais n√£o permitido');
    }
    
    const response = await fetch(url, {
      headers: {
        'User-Agent': 'Inclua-AI/1.0'
      },
      timeout: 10000 // 10 segundos timeout
    });
    
    if (!response.ok) {
      throw new Error(`Erro HTTP: ${response.status} ${response.statusText}`);
    }

    const contentType = response.headers.get('content-type');
    if (!contentType || !contentType.startsWith('image/')) {
      throw new Error(`URL n√£o √© uma imagem v√°lida. Content-Type: ${contentType}`);
    }
    
    // Verificar tamanho da imagem
    const contentLength = response.headers.get('content-length');
    if (contentLength && parseInt(contentLength) > 10 * 1024 * 1024) { // 10MB
      throw new Error('Imagem muito grande (m√°ximo 10MB)');
    }

    const buffer = await response.arrayBuffer();
    
    // Verificar tamanho real
    if (buffer.byteLength > 10 * 1024 * 1024) {
      throw new Error('Imagem muito grande (m√°ximo 10MB)');
    }
    
    const base64 = Buffer.from(buffer).toString('base64');

    console.log(`‚úÖ Imagem processada: ${(buffer.byteLength / 1024).toFixed(1)}KB`);
    
    return {
      inlineData: {
        data: base64,
        mimeType: contentType,
      },
    };
  } catch (error) {
    console.error('‚ùå Erro ao processar imagem:', error.message);
    throw error;
  }
}

// 7. Rate limiting inteligente (em mem√≥ria)
const requestCounts = new Map();
const RATE_LIMIT = 20; // requests por minuto (mais restritivo)
const RATE_WINDOW = 60000; // 1 minuto
const BURST_LIMIT = 5; // m√°ximo 5 requests em 10 segundos
const BURST_WINDOW = 10000; // 10 segundos

function checkRateLimit(ip) {
  const now = Date.now();
  const userRequests = requestCounts.get(ip) || [];
  
  // Remove requests antigas
  const recentRequests = userRequests.filter(time => now - time < RATE_WINDOW);
  const burstRequests = userRequests.filter(time => now - time < BURST_WINDOW);
  
  // Verificar limite de burst
  if (burstRequests.length >= BURST_LIMIT) {
    return { allowed: false, reason: 'burst' };
  }
  
  // Verificar limite geral
  if (recentRequests.length >= RATE_LIMIT) {
    return { allowed: false, reason: 'rate' };
  }
  
  recentRequests.push(now);
  requestCounts.set(ip, recentRequests);
  return { allowed: true };
}

// 8. Middleware de rate limiting melhorado
function rateLimitMiddleware(req, res, next) {
  const clientIP = req.ip || req.connection.remoteAddress || 'unknown';
  
  const rateCheck = checkRateLimit(clientIP);
  
  if (!rateCheck.allowed) {
    const message = rateCheck.reason === 'burst' 
      ? 'Muitas requisi√ß√µes muito r√°pidas. Aguarde 10 segundos.'
      : 'Limite de requisi√ß√µes excedido. Tente novamente em 1 minuto.';
      
    const retryAfter = rateCheck.reason === 'burst' ? 10 : 60;
    
    return res.status(429).json({ 
      error: message,
      retryAfter,
      type: rateCheck.reason
    });
  }
  
  next();
}

// 9. ENDPOINTS DA API

// Health check com teste da API Gemini
app.get('/health', async (req, res) => {
  try {
    // Teste b√°sico da API Gemini
    const testPrompt = "Responda apenas: OK";
    const testResult = await callGeminiWithRetry(() => 
      model.generateContent(testPrompt), 1 // Apenas 1 tentativa para health check
    );
    
    res.json({ 
      status: 'ok', 
      service: 'Inclua-AI Server',
      api: 'Google Gemini 1.5 Flash',
      geminiStatus: 'available',
      timestamp: new Date().toISOString(),
      uptime: process.uptime()
    });
  } catch (error) {
    // API indispon√≠vel, mas servidor est√° funcionando
    res.status(200).json({ 
      status: 'degraded', 
      service: 'Inclua-AI Server',
      api: 'Google Gemini 1.5 Flash',
      geminiStatus: 'unavailable',
      geminiError: error.message.includes('overloaded') ? 'overloaded' : 'error',
      timestamp: new Date().toISOString(),
      uptime: process.uptime()
    });
  }
});

// Descri√ß√£o de imagens
app.post('/describe-image', rateLimitMiddleware, async (req, res) => {
  const startTime = Date.now();
  console.log('üñºÔ∏è Recebida requisi√ß√£o para descrever imagem...');
  
  try {
    const { imageUrl } = req.body;
    
    // Valida√ß√£o de entrada
    if (!imageUrl || typeof imageUrl !== 'string') {
      return res.status(400).json({ error: 'URL da imagem √© obrigat√≥ria e deve ser uma string.' });
    }

    // Valida se √© uma URL
    try {
      new URL(imageUrl);
    } catch {
      return res.status(400).json({ error: 'URL da imagem inv√°lida.' });
    }

    const imageParts = [await urlToGenerativePart(imageUrl)];
    const prompt = `Analise esta imagem e crie uma descri√ß√£o acess√≠vel em portugu√™s para pessoas com defici√™ncia visual.

Diretrizes:
- Seja objetivo e conciso (m√°ximo 2-3 frases)
- Descreva os elementos principais e o contexto
- Use linguagem clara e descritiva
- Foque no que √© mais importante visualmente

Responda apenas com a descri√ß√£o, sem explica√ß√µes adicionais.`;

    const result = await callGeminiWithRetry(() => 
      model.generateContent([prompt, ...imageParts])
    );
    const description = result.response.text().trim();

    const responseTime = Date.now() - startTime;
    console.log(`‚úÖ Descri√ß√£o gerada em ${responseTime}ms: ${description.substring(0, 100)}...`);
    
    res.json({ description });
    
  } catch (error) {
    const responseTime = Date.now() - startTime;
    console.error(`‚ùå Erro ap√≥s ${responseTime}ms:`, error.message);
    
    // Tratamento espec√≠fico de erros da API Gemini
    if (error.message.includes('overloaded') || error.message.includes('503')) {
      res.status(503).json({ 
        error: 'Servi√ßo de IA temporariamente sobrecarregado. Tente novamente em alguns segundos.',
        retryAfter: 5
      });
    } else if (error.message.includes('SAFETY')) {
      res.status(400).json({ error: 'Imagem rejeitada por quest√µes de seguran√ßa.' });
    } else if (error.message.includes('quota') || error.message.includes('429')) {
      res.status(429).json({ 
        error: 'Quota da API excedida. Tente novamente mais tarde.',
        retryAfter: 60
      });
    } else {
      res.status(500).json({ error: 'Falha ao gerar descri√ß√£o da imagem.' });
    }
  }
});

// Resumo de texto
app.post('/summarize-text', rateLimitMiddleware, async (req, res) => {
  console.log('üìù Recebida requisi√ß√£o para resumir texto...');
  
  try {
    const { textToSummarize } = req.body;
    
    if (!textToSummarize || typeof textToSummarize !== 'string') {
      return res.status(400).json({ error: 'Texto para resumir √© obrigat√≥rio.' });
    }

    if (textToSummarize.length < 50) {
      return res.status(400).json({ error: 'Texto muito curto para resumir (m√≠nimo 50 caracteres).' });
    }

    if (textToSummarize.length > 10000) {
      return res.status(400).json({ error: 'Texto muito longo (m√°ximo 10.000 caracteres).' });
    }

    const prompt = `Crie um resumo conciso e objetivo do texto a seguir em portugu√™s:

TEXTO:
"${textToSummarize}"

INSTRU√á√ïES:
- Extraia apenas os pontos mais importantes
- Use 2-4 frases m√°ximo
- Mantenha o tom e contexto original
- Seja claro e direto

RESUMO:`;

    const result = await callGeminiWithRetry(() => 
      model.generateContent(prompt)
    );
    const summarizedText = result.response.text().trim();

    console.log('‚úÖ Resumo gerado com sucesso');
    res.json({ summarizedText });
    
  } catch (error) {
    console.error('‚ùå Erro ao resumir texto:', error.message);
    
    // Tratamento espec√≠fico de erros da API Gemini
    if (error.message.includes('overloaded') || error.message.includes('503')) {
      res.status(503).json({ 
        error: 'Servi√ßo de IA temporariamente sobrecarregado. Tente novamente em alguns segundos.',
        retryAfter: 5
      });
    } else if (error.message.includes('quota') || error.message.includes('429')) {
      res.status(429).json({ 
        error: 'Quota da API excedida. Tente novamente mais tarde.',
        retryAfter: 60
      });
    } else {
      res.status(500).json({ error: 'Falha ao gerar resumo do texto.' });
    }
  }
});

// Simplifica√ß√£o de texto
app.post('/simplify-text', rateLimitMiddleware, async (req, res) => {
  console.log('üî§ Recebida requisi√ß√£o para simplificar texto...');
  
  try {
    const { textToSimplify } = req.body;
    
    if (!textToSimplify || typeof textToSimplify !== 'string') {
      return res.status(400).json({ error: 'Texto para simplificar √© obrigat√≥rio.' });
    }

    if (textToSimplify.length > 5000) {
      return res.status(400).json({ error: 'Texto muito longo para simplificar (m√°ximo 5.000 caracteres).' });
    }

    const prompt = `Reescreva o texto a seguir em linguagem muito simples e acess√≠vel:

TEXTO ORIGINAL:
"${textToSimplify}"

INSTRU√á√ïES:
- Use palavras simples e comuns
- Frases curtas e diretas
- Como se explicasse para uma crian√ßa de 12 anos
- Mantenha todas as informa√ß√µes importantes
- N√£o adicione opini√µes pr√≥prias

TEXTO SIMPLIFICADO:`;

    const result = await callGeminiWithRetry(() => 
      model.generateContent(prompt)
    );
    const simplifiedText = result.response.text().trim();

    console.log('‚úÖ Texto simplificado gerado');
    res.json({ simplifiedText });
    
  } catch (error) {
    console.error('‚ùå Erro ao simplificar texto:', error.message);
    res.status(500).json({ error: 'Falha ao simplificar o texto.' });
  }
});

// NOVA FEATURE: An√°lise de contraste de cores
app.post('/analyze-contrast', rateLimitMiddleware, async (req, res) => {
  console.log('üé® Recebida requisi√ß√£o para analisar contraste...');
  
  try {
    const { foregroundColor, backgroundColor, elementType = 'texto' } = req.body;
    
    if (!foregroundColor || !backgroundColor) {
      return res.status(400).json({ error: 'Cores de primeiro plano e fundo s√£o obrigat√≥rias.' });
    }

    const prompt = `Analise o contraste entre as cores fornecidas para acessibilidade web:

CORES:
- Primeiro plano (texto): ${foregroundColor}
- Fundo: ${backgroundColor}
- Tipo de elemento: ${elementType}

Forne√ßa uma an√°lise completa incluindo:
1. Ratio de contraste aproximado
2. Conformidade com WCAG (AA/AAA)
3. Sugest√µes de melhoria se necess√°rio
4. Cores alternativas mais acess√≠veis

Responda em formato JSON com as chaves: ratio, wcagCompliance, suggestions, alternativeColors`;

    const result = await callGeminiWithRetry(() => 
      model.generateContent(prompt)
    );
    const analysis = result.response.text().trim();

    console.log('‚úÖ An√°lise de contraste gerada');
    res.json({ analysis });
    
  } catch (error) {
    console.error('‚ùå Erro ao analisar contraste:', error.message);
    res.status(500).json({ error: 'Falha ao analisar contraste de cores.' });
  }
});

// NOVA FEATURE: Gera√ß√£o de alt-text autom√°tico
app.post('/generate-alt-text', rateLimitMiddleware, async (req, res) => {
  console.log('üè∑Ô∏è Recebida requisi√ß√£o para gerar alt-text...');
  
  try {
    const { imageUrl, context = '' } = req.body;
    
    if (!imageUrl || typeof imageUrl !== 'string') {
      return res.status(400).json({ error: 'URL da imagem √© obrigat√≥ria.' });
    }

    try {
      new URL(imageUrl);
    } catch {
      return res.status(400).json({ error: 'URL da imagem inv√°lida.' });
    }

    const imageParts = [await urlToGenerativePart(imageUrl)];
    const prompt = `Gere um texto alternativo (alt-text) otimizado para esta imagem:

CONTEXTO DA P√ÅGINA: ${context || 'N√£o fornecido'}

DIRETRIZES PARA ALT-TEXT:
- M√°ximo 125 caracteres
- Descreva a fun√ß√£o/prop√≥sito da imagem no contexto
- Se decorativa, indique "Imagem decorativa"
- Se informativa, seja preciso e conciso
- Se complexa (gr√°fico/diagrama), descreva os dados principais
- Use linguagem clara e objetiva

Responda apenas com o alt-text, sem aspas ou explica√ß√µes.`;

    const result = await callGeminiWithRetry(() => 
      model.generateContent([prompt, ...imageParts])
    );
    const altText = result.response.text().trim();

    console.log('‚úÖ Alt-text gerado');
    res.json({ altText });
    
  } catch (error) {
    console.error('‚ùå Erro ao gerar alt-text:', error.message);
    res.status(500).json({ error: 'Falha ao gerar alt-text.' });
  }
});

// NOVA FEATURE: An√°lise de acessibilidade da p√°gina
app.post('/analyze-accessibility', rateLimitMiddleware, async (req, res) => {
  console.log('‚ôø Recebida requisi√ß√£o para an√°lise de acessibilidade...');
  
  try {
    const { htmlContent, pageUrl = '' } = req.body;
    
    if (!htmlContent || typeof htmlContent !== 'string') {
      return res.status(400).json({ error: 'Conte√∫do HTML √© obrigat√≥rio.' });
    }

    const prompt = `Analise o c√≥digo HTML fornecido para problemas de acessibilidade:

HTML:
${htmlContent}

URL da p√°gina: ${pageUrl}

Identifique e liste problemas de acessibilidade seguindo as diretrizes WCAG 2.1:

1. ESTRUTURA:
- Falta de headings hier√°rquicos
- Landmarks ARIA ausentes
- Elementos sem√¢nticos inadequados

2. IMAGENS:
- Alt-text ausente ou inadequado
- Imagens decorativas sem aria-hidden

3. FORMUL√ÅRIOS:
- Labels ausentes
- Fieldsets sem legend
- Instru√ß√µes inadequadas

4. NAVEGA√á√ÉO:
- Links sem texto descritivo
- Foco n√£o vis√≠vel
- Skip links ausentes

5. CORES E CONTRASTE:
- Depend√™ncia apenas de cor
- Contraste insuficiente

Forne√ßa resposta em formato JSON com: problems (array), severity (high/medium/low), suggestions (array)`;

    const result = await callGeminiWithRetry(() => 
      model.generateContent(prompt)
    );
    const analysis = result.response.text().trim();

    console.log('‚úÖ An√°lise de acessibilidade gerada');
    res.json({ analysis });
    
  } catch (error) {
    console.error('‚ùå Erro ao analisar acessibilidade:', error.message);
    res.status(500).json({ error: 'Falha ao analisar acessibilidade.' });
  }
});

// NOVA FEATURE: Explica√ß√£o de f√≥rmulas matem√°ticas
app.post('/explain-math', rateLimitMiddleware, async (req, res) => {
  console.log('üßÆ Recebida requisi√ß√£o para explicar matem√°tica...');
  
  try {
    const { mathExpression, level = 'intermedi√°rio' } = req.body;
    
    if (!mathExpression || typeof mathExpression !== 'string') {
      return res.status(400).json({ error: 'Express√£o matem√°tica √© obrigat√≥ria.' });
    }

    const prompt = `Explique a seguinte express√£o matem√°tica de forma acess√≠vel:

EXPRESS√ÉO: ${mathExpression}
N√çVEL: ${level}

Forne√ßa:
1. Leitura em portugu√™s (como um leitor de tela leria)
2. Explica√ß√£o passo a passo
3. Contexto/aplica√ß√£o pr√°tica
4. Resultado (se aplic√°vel)

Use linguagem adequada ao n√≠vel ${level} e seja muito claro para pessoas com defici√™ncia visual.`;

    const result = await callGeminiWithRetry(() => 
      model.generateContent(prompt)
    );
    const explanation = result.response.text().trim();

    console.log('‚úÖ Explica√ß√£o matem√°tica gerada');
    res.json({ explanation });
    
  } catch (error) {
    console.error('‚ùå Erro ao explicar matem√°tica:', error.message);
    res.status(500).json({ error: 'Falha ao explicar express√£o matem√°tica.' });
  }
});

// 10. Middleware de erro global
app.use((error, req, res, next) => {
  const timestamp = new Date().toISOString();
  const ip = req.ip || req.connection.remoteAddress || 'unknown';
  
  console.error(`‚ùå [${timestamp}] Erro n√£o tratado de ${ip}:`, {
    error: error.message,
    stack: error.stack,
    url: req.url,
    method: req.method,
    userAgent: req.get('User-Agent')
  });
  
  res.status(500).json({ 
    error: 'Erro interno do servidor.',
    timestamp,
    requestId: `req_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
  });
});

// 11. Inicia o servidor
const PORT = process.env.PORT || 3000;
app.listen(PORT, () => {
  console.log('üöÄ ========================================');
  console.log(`üéØ Servidor Inclua-AI rodando na porta ${PORT}`);
  console.log(`üåê Local: http://localhost:${PORT}`);
  console.log(`üîó Render: https://inclua-ai-servidor.onrender.com`);
  console.log(`ü§ñ API: Google Gemini 1.5 Flash`);
  console.log(`‚ö° Rate Limit: ${RATE_LIMIT} req/min (burst: ${BURST_LIMIT} req/10s)`);
  console.log(`üõ°Ô∏è Seguran√ßa: SSRF protection, size limits, timeout controls`);
  console.log(`üìä Features: 7 AI endpoints + health check`);
  console.log('üöÄ ========================================');
});
